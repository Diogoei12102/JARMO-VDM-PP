class Game
types
public Board = set of Position;
public CurrentPlayer = nat1;
values

instance variables
private board: Board;
private currentPlayer: CurrentPlayer ;
private players: set of nat1;

operations
public Game: ()==> Game
	Game() == (
			--dcl p: Position ;
			dcl p1: Position := new Position(0,0,1);
			dcl p2: Position := new Position(0,1,1);
			dcl p3: Position := new Position(0,2,1);
			dcl p4: Position := new Position(0,3,1);
			dcl p5: Position := new Position(0,4,1);
			dcl p6: Position := new Position(1,0,0);
			dcl p7: Position := new Position(1,1,0);
			dcl p8: Position := new Position(1,2,0);
			dcl p9: Position := new Position(1,3,0);
			dcl p10: Position := new Position(1,4,0);
			dcl p11: Position := new Position(2,0,0);
			dcl p12: Position := new Position(2,1,0);
			dcl p13: Position := new Position(2,2,0);
			dcl p14: Position := new Position(2,3,0);
			dcl p15: Position := new Position(2,4,0);
			dcl p16: Position := new Position(3,0,0);
			dcl p17: Position := new Position(3,1,0);
			dcl p18: Position := new Position(3,2,0);
			dcl p19: Position := new Position(3,3,0);
			dcl p20: Position := new Position(3,4,0);
			dcl p21: Position := new Position(4,0,2);
			dcl p22: Position := new Position(4,1,2);
			dcl p23: Position := new Position(4,2,2);
			dcl p24: Position := new Position(4,3,2);
			dcl p25: Position := new Position(4,4,2);
			
			p1.addValidMoves({p8, p12});
			p2.addValidMoves({p9, p11});
			p3.addValidMoves({p6, p10, p14});
			p4.addValidMoves({p7, p13});
			p5.addValidMoves({p8, p14});
			p6.addValidMoves({p3, p13});
			p7.addValidMoves({p4, p8, p12, p18});
			p8.addValidMoves({p1, p5, p7, p9, p15});
			p9.addValidMoves({p2, p8, p12, p14});
			p10.addValidMoves({p3, p19});
			p11.addValidMoves({p2, p22});
			p12.addValidMoves({p1, p6, p9, p17, p21, p22});
			p13.addValidMoves({p4, p6, p16, p20});
			p14.addValidMoves({p3, p5, p9, p17, p19, p25});
			p15.addValidMoves({p8, p24});
			p16.addValidMoves({p13, p23});
			p17.addValidMoves({p12, p14, p18, p24});
			p18.addValidMoves({p7, p17, p19, p21, p25});
			p19.addValidMoves({p10, p14, p18, p22});
			p20.addValidMoves({p6, p23});
			p21.addValidMoves({p12, p18});
			p22.addValidMoves({p11, p19});
			p23.addValidMoves({p12, p16, p20});
			p24.addValidMoves({p15, p17});
			p25.addValidMoves({p14, p18});
			
			board := {p1, p2, p3, p4, p5, 
								p6, p7, p8, p9, p10, 
								p11, p12, p13, p14, p15, 
								p16, p17, p18, p19, p20, 
								p21, p22, p23, p24, p25};
								
		-- temos de criar as posicoes todas do tabuleiro
		-- dcl p1: Position := new Position(0,0,1); podiamos arranjar maneira de em vez de 0 1 ou 2 meter mesmo um jogador e era fixe criar estas posi�oes com um for
			currentPlayer := 1; --escolhe aleatoriamente quem comeca
			players := {1, 2};
			
--for x = 0 to 4 do 
--			for y = 0 to 4 do 
--			(if x = 0 then		
--			p := new Position(x,y,1)
--			elseif x = 4 then
--			p := new Position(x,y,2)
--			else
--			p := new Position(x,y,0);
--			
-- 	  	board := board union {p};);-- nao sei se isto est� dentro do for
			-- adicionar ao board	
		
		return self;
	);
	
public getBoard : () ==>  Board
        	getBoard() == (
        	return board;
        	);

public getPlayers : () ==>  set of nat1
        	getPlayers() == (
        	return players;
        	);
        	       		      	
public changePlayer : () ==> ()
				changePlayer() == (
					currentPlayer := iota x in set players & x <> currentPlayer;
					);
					
public setBoard : Board ==> ()
        	setBoard(b) == (
        	board := b;
        	);
			
public isMoveValid : Position * Position ==> bool
			isMoveValid(pi, pf) == (
				dcl valid : bool := true;
					if pf not in set pi.getValidMoves()
						then valid := false;
					return valid;
					);
					
functions
        	
traces
-- TODO Define Combinatorial Test Traces here
end Game